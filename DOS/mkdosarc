#!/bin/bash -p
###############################################################################
# BRLTTY - A background process providing access to the console screen (when in
#          text mode) for a blind person using a refreshable braille display.
#
# Copyright (C) 1995-2014 by The BRLTTY Developers.
#
# BRLTTY comes with ABSOLUTELY NO WARRANTY.
#
# This is free software, placed under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any
# later version. Please see the file LICENSE-GPL for details.
#
# Web Page: http://mielke.cc/brltty/
#
# This software is maintained by Dave Mielke <dave@mielke.cc>.
###############################################################################

set -e
shopt -s nullglob

defaultArchiveName="brltty-dos"
defaultInstallDirectory="BRLTTY"

. "`dirname "${0}"`/../prologue.sh"
addProgramOption a string.name archiveName "specify archive name (default is ${defaultArchiveName})"
addProgramOption i string.directory installDirectory "specify installation directory on target system (default is ${defaultInstallDirectory})"
addProgramOption n flag reportShortNameCollisions "report short name collisions"
addProgramOption o flag overwriteArchive "overwrite existing archive"
addProgramOption s flag invokeShell "invoke interactive shell to inspect/modify result"
addProgramParameter source sourceDirectory "top-level directory of source tree"
eval "${parseProgramOptions}"

[ -n "${archiveName}" ] || archiveName="${defaultArchiveName}"
[ -n "${installDirectory}" ] || installDirectory="${defaultInstallDirectory}"

[ -n "${sourceDirectory}" ] || sourceDirectory="."
verifyInputDirectory "${sourceDirectory}" || semanticError
sourceDirectory="$(resolveDirectory "${sourceDirectory}")"

archivePath="${initialDirectory}/${archiveName}.zip"
[ ! -e "${archivePath}" ] || {
   "${overwriteArchive}" ] || semanticError "archive already exists: ${archivePath}"
   rm -f -r "${archivePath}"
}

function convertTextFile {
   local file="${1}"

   unix2dos -q -o "${file}"
}

function installFile {
   local sourceFile="${1}"
   local targetFile="${2}"

   targetFile="${installDirectory}/${targetFile}"
   local targetDirectory="${targetFile%/*}"
   mkdir -p "${targetDirectory}"
   cp "${sourceFile}" "${targetFile}"
}

function installManualFiles {
   local directory="${1}"

   cd "${directory}/Documents/Manual-BRLTTY"

   for file in $(find . -type f)
   do
      case "${file##*/}"
      in
         *.txt | *.htm | *.html | *.doc | *.pdf)
            installFile "${file}" "${manualSubdirectory}/${file}"
            ;;
      esac
   done
}

needTemporaryDirectory

buildDirectory="${temporaryDirectory}/build"
mkdir -p "${buildDirectory}"

installDirectory="${temporaryDirectory}/intall/${installDirectory}"
mkdir -p "${installDirectory}"
documentSubdirectory="doc"
manualSubdirectory="${documentSubdirectory}/Manual"

cd "${buildDirectory}"
"${sourceDirectory}/cfg-dos" --enable-relocatable-install --prefix="${installDirectory}"
make -s all
make -s -C Programs ktbtest.exe tunetest.exe
make -s -C Documents
make -s install

cd "${installDirectory}/bin"
rm brltty-config
rm brltty-install
mv brltty-ttb.exe brlttb.exe
mv brltty-ctb.exe brlctb.exe
mv brltty-trtxt.exe brltrtxt.exe

cd "${buildDirectory}/Programs"
installFile ktbtest.exe bin/brlktb.exe
installFile tunetest.exe bin/brltune.exe

cd "${sourceDirectory}/DOS"
installFile cwsdpmi.exe "bin/cwsdpmi.exe"

cd "${sourceDirectory}/Drivers"
name=README
for driverType in Braille Speech
do
   cd "${driverType}"

   for driverName in *
   do
      cd "${driverName}"
      typeset -u driverCode="$(sed -n -e '/^ *DRIVER_CODE *= */s/^.*= *//p' "Makefile.in")"

      for file in "${name}"*
      do
         document="${file/#${name}/${driverCode}}"
         document="${document//./-}"
         installFile "${file}" "${documentSubdirectory}/Drivers/${driverType}/${document}.txt"
      done

      cd ..
   done

   cd ..
done

cd "${sourceDirectory}"
installFile "LICENSE-GPL" "LIC-GPL.txt"
installFile "LICENSE-LGPL" "LIC-LGPL.txt"
installFile "README" "README.txt"
installFile "Documents/README.MSDOS" "MSDOS.txt"
installFile "Documents/ChangeLog" "${documentSubdirectory}/CHANGES.txt"
installFile "Documents/HISTORY" "${documentSubdirectory}/HISTORY.txt"
installFile "Documents/TODO" "${documentSubdirectory}/TODO.txt"

installManualFiles "${sourceDirectory}"
installManualFiles "${buildDirectory}"

cd "${buildDirectory}"
installFile "Documents/brltty.conf" "etc/brltty.cfg"

cd "${installDirectory}"
mv share/man .
rm -f -r share
cd man

for source in */*
do
   target="${source/%?/txt}"
   MANWIDTH=80 LC_ALL=C man "${source}" | ul -t dumb | expand | uniq >"${target}"
   rm "${source}"
done

! "${invokeShell}" || {
   cd "${installDirectory}"
   "${SHELL:-/bin/sh}" || :
}

cd "${installDirectory}"
find . -print |
   while read path
   do
      handle="${path#.}"
      [ -n "${handle}" ] || continue

      name="${path##*/}"
      extension="${name##*.}"

      if [ -f "${path}" ]
      then
         if [ "${extension}" = "${name}" ]
         then
            programMessage "file without an extension: ${handle}"
         else
            case "${extension}"
            in
               txt | html | htm | cfg | [tack]t[bi] | h) convertTextFile "${path}";;
               exe | pdf | doc);;
               *) programMessage "unexpected file extension: ${handle}";;
            esac
         fi
      elif [ -d "${path}" ]
      then
         if [ "${extension}" != "${name}" ]
         then
            programMessage "directory with an extension: ${handle}"
         fi
      else
         programMessage "special file: ${handle}"
      fi
   done

! "${reportShortNameCollisions}" || {
   cd "${installDirectory}"
   find . -type d -print |
      while read directory
      do
         declare -A shortNames=()

         for longName in $(ls -1 --quote-name --quoting-style=shell "${directory}")
         do
            delimiter="."
            prefix="${longName%${delimiter}*}"

            if [ "${prefix}" = "${longName}" ]
            then
               suffix=""
               delimiter=""
            else
               suffix="${longName:${#prefix}+${#delimiter}}"
            fi

            prefix="${prefix:0:8}"
            suffix="${suffix:0:3}"
            declare -l shortName="${prefix}${delimiter}${suffix}"

            if [ "${#shortNames["${shortName}"]}" -eq 0 ]
            then
               shortNames["${shortName}"]="${longName}"
            else
               programMessage "short name collision: ${directory#.}: ${shortNames["${shortName}"]} & ${longName}"
            fi
         done
      done
}

cd "${installDirectory}/.."
zip -q -r "${archivePath}" "${installDirectory##*/}"
exit 0
