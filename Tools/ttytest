#!/usr/bin/env tclsh
###############################################################################
# BRLTTY - A background process providing access to the console screen (when in
#          text mode) for a blind person using a refreshable braille display.
#
# Copyright (C) 1995-2021 by The BRLTTY Developers.
#
# BRLTTY comes with ABSOLUTELY NO WARRANTY.
#
# This is free software, placed under the terms of the
# GNU Lesser General Public License, as published by the Free Software
# Foundation; either version 2.1 of the License, or (at your option) any
# later version. Please see the file LICENSE-LGPL for details.
#
# Web Page: http://brltty.app/
#
# This software is maintained by Dave Mielke <dave@mielke.cc>.
###############################################################################

source [file join [file dirname [info script]] .. brltty-prologue.tcl]

proc addSerialProperty {propertiesVariable name label choices default} {
   if {[set index [lsearch -exact $choices $default]] < 0} {
      return -code error "unsupported $label: $default"
   }

   uplevel 1 [list dict set $propertiesVariable $name [dict create label $label choices $choices requested $index]]
}

proc makeSerialProperties {} {
   set properties [dict create]
   addSerialProperty properties lineType "line type" {local modem} local
   addSerialProperty properties baud "baud" {50 75 110 134 150 200 300 600 1200 1800 2400 4800 9600 19200 38400 57600 115200 230400 460800 500000 576000 921600 1000000 1152000 1500000 2000000 2500000 3000000 3500000 4000000} 38400
   addSerialProperty properties flowControl "flow control" {no hardware software} no
   addSerialProperty properties dataParity "data parity" {none odd even} none
   addSerialProperty properties dataBits "data bits" {5 6 7 8} 8
   addSerialProperty properties stopBits "stop bits" {1 2} 1
   return $properties
}

set serialProperties [makeSerialProperties]
set devicePath "/dev/ttyS0"

proc getPropertyValue {name} {
   global serialProperties
   set property [dict get $serialProperties $name]
   return [lindex [dict get $property choices] [dict get $property requested]]
}

proc logRequestedConfiguration {} {
   upvar #0 serialProperties properties
   global devicePath
   set log "requested cofiguration: $devicePath"

   foreach name [dict keys $properties] {
      set property [dict get $properties $name]
      append log ", [getPropertyValue $name]"
      append log " [dict get $property label]"
   }

   logMessage task $log
}

proc configureDevice {{options {-g}}} {
   global devicePath

   set command [list]
   lappend command stty -F $devicePath
   eval lappend command $options
   logMessage step "command: [join $command " "]"
   lappend command 2>@ stderr

   if {[catch [linsert $command 0 exec] response] != 0} {
      exit 4
   }

   return $response
}

set optionDefinitions {
}

processProgramArguments optionValues $optionDefinitions positionalArguments "\[property ...\]"

foreach argument $positionalArguments {
   if {[cequal [file pathtype $argument] absolute]} {
      set devicePath $argument
   } else {
      set found 0

      foreach name [dict keys $serialProperties] {
         if {[set index [lsearch -exact [dict get $serialProperties $name choices] $argument]] >= 0} {
            set found 1
            dict set serialProperties $name requested $index
            break
         }
      }

      if {!$found} {
         syntaxError "unrecognized serial property: $argument"
      }
   }
}

foreach {test word} {exists "found" readable "readable" writable "writable"} {
   if {![file $test $devicePath]} {
      semanticError "device not $word: $devicePath"
   }
}

if {![string equal [file type $devicePath] characterSpecial]} {
   semanticError "not a serial device: $devicePath"
}

logRequestedConfiguration
set originalSettings [configureDevice]
set requestedSettings [list raw -echo -echoe -echok -echonl]

lappend requestedSettings [getPropertyValue baud]
lappend requestedSettings cs[getPropertyValue dataBits]

foreach {name test value option} {
   lineType != 1 clocal
   flowControl == 1 crtscts
   flowControl == 2 ixon
   dataParity != 0 parenb
   dataParity == 1 parodd
   stopBits == 2 cstopb
} {
   if "!([dict get $serialProperties $name requested] $test $value)" {
      set option "-$option"
   }

   lappend requestedSettings $option
}

try {
   configureDevice $requestedSettings

   try {
      withChannel deviceChannel [open $devicePath {RDWR NOCTTY NONBLOCK}] {
         fconfigure $deviceChannel -buffering none -translation binary

         fileevent $deviceChannel readable {
            scan [read $deviceChannel 1] %c byte
            puts -nonewline stdout [format "%2.2x " $byte]
            flush stdout
         }

         fileevent stdin readable {
            if {[set length [gets stdin line]] == 0} {
               set exitStatus 0
            } elseif {$length > 0} {
               puts -nonewline $deviceChannel [subst -nocommands -novariables $line]
               flush $deviceChannel
            } elseif {[eof stdin]} {
               set exitStatus 0
            }
         }

         vwait exitStatus
      }
   } trap {POSIX} {problem} {
      semanticError $message
   }
} finally {
   configureDevice $originalSettings
}

exit $exitStatus
